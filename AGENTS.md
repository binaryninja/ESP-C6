# AGENTS.md - ESP32-C6 Development Environment & Lessons Learned

## Overview
This document captures the essential knowledge and lessons learned while setting up a comprehensive ESP32-C6 development environment for the end-to-end tutorial. Future agents working on this project MUST read this document first.

## üöÄ **QUICK START FOR NEW AGENTS**

### Essential Reading Order
1. **Read this file completely** - Understanding project architecture and lessons learned
2. **Review `DEV_MONITOR_README.md`** - Complete guide to development workflow and testing
3. **Check `README.md`** - Project overview and hardware setup
4. **Use `./dev_monitor.sh`** - Enhanced development script for all build/test operations

### Development Workflow
```bash
# Quick verification that everything works
./dev_monitor.sh flash-test

# Development with dual monitoring (recommended)
./dev_monitor.sh dual 120

# See all available commands
./dev_monitor.sh help
```

## Environment Setup (WORKING)

### System Information
- **Host OS**: Ubuntu 24.04
- **IDF Version**: v5.4.1 (latest LTS for C6)
- **Board**: ESP32-C6-DevKit-1 on /dev/ttyACM0
- **Shell**: /bin/bash

### ESP-IDF Installation Process (VERIFIED WORKING)

1. **Prerequisites Installation** ‚úÖ
```bash
sudo apt-get update
sudo apt-get install -y git wget flex bison gperf python3 python3-pip python3-venv python3-setuptools cmake ninja-build ccache libffi-dev libssl-dev dfu-util libusb-1.0-0 build-essential
```

2. **ESP-IDF Setup** ‚úÖ
```bash
# ESP-IDF is installed at: /home/mike/esp/esp-idf
# Version: v5.4.1 (confirmed working)
cd /home/mike/esp/esp-idf
./install.sh esp32c6
```

3. **Environment Activation** ‚úÖ
```bash
export IDF_PATH=/home/mike/esp/esp-idf
source $IDF_PATH/export.sh
```

4. **Verification** ‚úÖ
```bash
idf.py --version
# Should output: ESP-IDF v5.4.1
```

### Current Project Build Process (FULLY FUNCTIONAL) ‚úÖ

**Use the enhanced development script instead of manual commands:**

```bash
# Recommended development workflow
./dev_monitor.sh flash-test    # Build, flash, and test
./dev_monitor.sh dual 60       # Dual monitoring with client simulation
./dev_monitor.sh build         # Build only
./dev_monitor.sh clean         # Clean build
```

**Current Working Project Structure:**
```
ESP-C6/
‚îú‚îÄ‚îÄ dev_monitor.sh              # ‚≠ê ENHANCED DEVELOPMENT SCRIPT
‚îú‚îÄ‚îÄ DEV_MONITOR_README.md       # ‚≠ê COMPLETE DEVELOPMENT GUIDE
‚îú‚îÄ‚îÄ README.md                   # Project overview and hardware setup
‚îú‚îÄ‚îÄ AGENTS.md                   # This file - development guidelines
‚îú‚îÄ‚îÄ logs/                       # Generated by dev_monitor.sh
‚îÇ   ‚îú‚îÄ‚îÄ client.log              # Client simulation logs
‚îÇ   ‚îú‚îÄ‚îÄ server.log              # ESP32-C6 serial output
‚îÇ   ‚îî‚îÄ‚îÄ combined.log            # Correlated client/server logs
‚îî‚îÄ‚îÄ firmware/                   # ESP-IDF project (WORKING)
    ‚îú‚îÄ‚îÄ CMakeLists.txt
    ‚îú‚îÄ‚îÄ sdkconfig.defaults
    ‚îú‚îÄ‚îÄ main/
    ‚îÇ   ‚îú‚îÄ‚îÄ CMakeLists.txt
    ‚îÇ   ‚îî‚îÄ‚îÄ firmware.c          # Main application with ST7789 display
    ‚îî‚îÄ‚îÄ components/
        ‚îú‚îÄ‚îÄ display/            # ST7789 display driver (WORKING)
        ‚îî‚îÄ‚îÄ lvgl/               # LVGL graphics library (WORKING)
```

## CRITICAL LESSONS LEARNED

### ‚ùå MAJOR MISTAKES TO AVOID

1. **DO NOT WRITE CUSTOM DRIVERS**
   - ESP-IDF already has comprehensive driver components
   - Available at: https://github.com/espressif/esp-idf/tree/master/components
   - Use existing components: `esp_driver_gpio`, `esp_driver_spi`, `esp_driver_i2c`, etc.

2. **DO NOT REINVENT EXISTING FUNCTIONALITY**
   - Wi-Fi: Use `esp_wifi` component and examples
   - BLE: Use `bt` component and existing GATT examples
   - Thread/Zigbee: Use `openthread` and official Zigbee SDK
   - ULP: Use `ulp` component with proper LP core examples

### ‚úÖ WHAT WORKS AND SHOULD BE USED

#### Wi-Fi 6 Implementation
- **Component to use**: `esp_wifi` (built-in)
- **Example location**: `$IDF_PATH/examples/wifi/`
- **Key features**: WPA3-SAE, 802.11ax support built-in
- **Configuration**: Use `idf.py menuconfig ‚Üí Component config ‚Üí Wi-Fi`

#### BLE 5.0 Implementation  
- **Component to use**: `bt` (built-in)
- **Example location**: `$IDF_PATH/examples/bluetooth/bluedroid/ble/`
- **Best starting point**: `gatt_server_service_table` example
- **Configuration**: Enable in menuconfig, coexistence works with Wi-Fi

#### Thread/OpenThread
- **Component to use**: `openthread` (built-in)
- **Add dependency**: `idf.py add-dependency "openthread/esp_openthread=*"`
- **Example location**: `$IDF_PATH/examples/openthread/`
- **Mode**: Use RCP (Radio Co-Processor) mode

#### Zigbee
- **Component**: External Zigbee SDK required
- **Repository**: https://github.com/espressif/esp-zigbee-sdk.git
- **Integration**: Add as git submodule
- **Examples**: In the Zigbee SDK repository

#### LP/ULP Core
- **Component to use**: `ulp` (built-in)
- **Examples**: `$IDF_PATH/examples/system/ulp/lp_core/`
- **Key function**: `ulp_lp_core_build_binary()` for building LP core binaries
- **Shared memory**: Use volatile variables for main CPU ‚Üî LP core communication

## WORKING COMPONENT EXAMPLES

### Component CMakeLists.txt Structure
```cmake
# For custom components using existing ESP-IDF functionality
idf_component_register(SRCS "source_file.c"
                       INCLUDE_DIRS "include"
                       REQUIRES esp_wifi esp_netif esp_event nvs_flash)
```

### LP Core Integration
```cmake
# In lp_core component CMakeLists.txt
idf_component_register(SRCS "lp_core_main.c"
                       INCLUDE_DIRS "include"
                       REQUIRES ulp)

set(lp_sources "lp_main.c")
ulp_lp_core_build_binary(lp_main "${lp_sources}")
```

## NEXT STEPS FOR FUTURE AGENTS

### 1. Use Existing Examples First
Before writing ANY custom code:
1. Check `$IDF_PATH/examples/` for relevant examples
2. Copy and modify existing examples rather than writing from scratch
3. Reference official ESP-IDF documentation

### 2. Component Integration Strategy
1. **Wi-Fi**: Start with `examples/wifi/getting_started/station`
2. **BLE**: Start with `examples/bluetooth/bluedroid/ble/gatt_server_service_table`
3. **Thread**: Start with `examples/openthread/ot_rcp`
4. **LP Core**: Start with `examples/system/ulp/lp_core/gpio`

### 3. Configuration Management
- Use `idf.py menuconfig` for enabling features
- Create `sdkconfig.defaults` for project defaults
- Enable coexistence for multiple radio protocols

### 4. Security Features
- Configure in menuconfig under "Security features"
- Secure Boot V2 and Flash Encryption available for C6
- Don't enable JTAG after secure boot

## TINYMCP INTEGRATION PLAN

### Overview
The project now includes a comprehensive plan to integrate TinyMCP (Model Context Protocol) server functionality into the ESP32-C6 firmware. This will enable AI/LLM integration and remote control capabilities.

### TinyMCP Reference Analysis ‚úÖ
- **Source Location**: `ESP-C6/REF-CODE/` contains TinyMCP C++ SDK
- **Architecture**: Lightweight MCP server implementation
- **Key Features**: Tools capability, JSON-RPC 2.0 protocol, stdio transport
- **Dependencies**: jsoncpp 1.9.5, standard C++ STL
- **Current Firmware**: C-based with ST7789 display, LVGL, FreeRTOS tasks

### Integration Challenges Identified ‚ùå
1. **Language Mismatch**: Firmware is C, TinyMCP is C++
2. **Platform Differences**: Desktop vs embedded constraints
3. **Transport Layer**: stdio vs UART/USB/WiFi/BLE
4. **Memory Constraints**: Embedded heap vs desktop memory
5. **Dependencies**: jsoncpp needs ESP32-compatible replacement

### Phase-by-Phase Implementation Plan

#### Phase 1: Project Structure & Build System Setup
**Status**: üîÑ READY TO IMPLEMENT
```
ESP-C6/firmware/components/tinymcp/
‚îú‚îÄ‚îÄ CMakeLists.txt
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ esp32_mcp_server.h
‚îÇ   ‚îú‚îÄ‚îÄ esp32_transport.h
‚îÇ   ‚îî‚îÄ‚îÄ mcp_tools.h
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ esp32_mcp_server.cpp
‚îÇ   ‚îú‚îÄ‚îÄ esp32_transport.cpp
‚îÇ   ‚îú‚îÄ‚îÄ display_tool.cpp
‚îÇ   ‚îú‚îÄ‚îÄ gpio_tool.cpp
‚îÇ   ‚îî‚îÄ‚îÄ system_tool.cpp
‚îî‚îÄ‚îÄ port/
    ‚îî‚îÄ‚îÄ (ported MCP core files)
```

#### Phase 2: Core MCP Components Porting
**Status**: üîÑ READY TO IMPLEMENT
**Priority Order**:
1. Port/replace JSON library (use ESP-IDF cJSON)
2. Port core MCP classes with ESP32 adaptations
3. Create ESP32-specific transport layer
4. Implement FreeRTOS task management

#### Phase 3: ESP32-C6 Hardware Integration
**Status**: üîÑ READY TO IMPLEMENT
**Key Components**:
- Convert `firmware.c` ‚Üí `firmware.cpp` for C++ support
- Integrate MCP server as FreeRTOS task
- Maintain existing display/GPIO/system functionality

#### Phase 4: ESP32-Specific MCP Tools
**Status**: üîÑ READY TO IMPLEMENT
**Tools to Implement**:
1. **DisplayTool**: Control ST7789 display, update LVGL widgets
2. **GPIOTool**: Control LED, read button, manage pins
3. **SystemTool**: Get system stats, heap info, uptime
4. **StatusTool**: Device health monitoring

#### Phase 5: Transport Layer Implementation
**Status**: üîÑ READY TO IMPLEMENT
**Priority Order**:
1. **UART/USB CDC Transport** (High Priority - MVP)
2. **WiFi TCP Transport** (Medium Priority)
3. **BLE Transport** (Low Priority - Enhancement)

### MCP Tools Schema Examples

#### DisplayTool Schema
```json
{
  "name": "display_control",
  "description": "Control ST7789 display and LVGL widgets",
  "inputSchema": {
    "type": "object",
    "properties": {
      "action": {"type": "string", "enum": ["show_text", "clear", "set_brightness"]},
      "text": {"type": "string", "description": "Text to display"},
      "x": {"type": "integer", "description": "X coordinate"},
      "y": {"type": "integer", "description": "Y coordinate"}
    },
    "required": ["action"]
  }
}
```

#### GPIOTool Schema
```json
{
  "name": "gpio_control",
  "description": "Control GPIO pins and read hardware state",
  "inputSchema": {
    "type": "object",
    "properties": {
      "action": {"type": "string", "enum": ["set_led", "read_button", "get_status"]},
      "state": {"type": "boolean", "description": "LED state for set_led action"}
    },
    "required": ["action"]
  }
}
```

### Implementation Priority

#### High Priority (MVP) ‚≠ê
- Basic MCP server with UART transport
- Display control tool
- GPIO control tool  
- System info tool
- C++ conversion of main firmware

#### Medium Priority üîÑ
- WiFi transport layer
- Advanced display tools
- Configuration management tools
- Error handling and logging

#### Low Priority (Enhancement) üìã
- BLE transport
- Web interface integration
- Mobile app support
- OTA updates via MCP

### Memory and Performance Considerations

#### Memory Optimization Strategy
- Use ESP32 heap management instead of std::malloc
- Implement object pooling for MCP messages
- Optimize JSON parsing for embedded constraints
- Use stack-based allocation where possible

#### Task Management
- Replace std::thread with FreeRTOS tasks
- Implement proper task priorities:
  - MCP Server Task: Priority 5
  - Display Task: Priority 4
  - System Monitor: Priority 3
  - Status LED: Priority 2
- Add watchdog integration for all tasks

### Build System Changes Required

#### Component CMakeLists.txt
```cmake
# ESP-C6/firmware/components/tinymcp/CMakeLists.txt
idf_component_register(
    SRCS "src/esp32_mcp_server.cpp"
         "src/esp32_transport.cpp"
         "src/display_tool.cpp"
         "src/gpio_tool.cpp"
         "src/system_tool.cpp"
    INCLUDE_DIRS "include"
    REQUIRES esp_timer freertos driver nvs_flash json esp_hw_support
)
```

#### Main Application Changes
```cmake
# ESP-C6/firmware/main/CMakeLists.txt
idf_component_register(SRCS "firmware.cpp"  # Changed from .c
                      INCLUDE_DIRS "."
                      REQUIRES tinymcp display lvgl)
```

### Configuration Requirements

#### ESP-IDF Configuration (menuconfig)
- Enable C++ support and exceptions
- Configure heap size (minimum 512KB recommended)
- Enable USB CDC for primary transport
- Configure task stack sizes:
  - MCP Server: 8192 bytes
  - Display: 4096 bytes
  - System Monitor: 4096 bytes

#### Security Considerations
- Implement MCP command authentication
- Rate limiting for MCP requests
- Secure transport options (TLS for WiFi)
- Command validation and sanitization

### Testing Strategy

#### Unit Testing
- JSON parsing and message handling
- Transport layer functionality
- Tool execution and response

#### Integration Testing
- MCP client-server communication
- Hardware control via MCP tools
- Display updates and GPIO control
- System monitoring and reporting

#### Performance Testing
- Memory usage monitoring
- Response time measurements
- Concurrent connection handling

## CURRENT PROJECT STATE

### What's Working ‚úÖ
- **ESP-IDF v5.4.1**: Complete installation and environment setup
- **ESP32-C6 Firmware**: Fully functional with ST7789 display support
- **Hardware Integration**: ST7789 320x172 TFT display, LED control, button input
- **LVGL Graphics**: Working UI with system statistics and real-time updates
- **FreeRTOS Tasks**: Multi-tasking with proper priorities and scheduling
- **Development Tooling**: Enhanced `dev_monitor.sh` script with dual monitoring
- **Logging Infrastructure**: Correlated client/server logging system
- **Build System**: Reliable ESP-IDF component structure
- **Testing Framework**: Automated hardware testing and validation

### What's Ready for TinyMCP Integration ‚úÖ
- **Architecture Analysis**: TinyMCP reference code studied and documented
- **Integration Plan**: Phased implementation strategy defined
- **Component Structure**: ESP32-specific MCP component design completed
- **Transport Layer**: UART/USB CDC transport planning finished
- **Tool Schemas**: DisplayTool, GPIOTool, SystemTool specifications ready
- **Build System**: C++ integration requirements identified
- **Testing Infrastructure**: Client simulation ready for real MCP testing

### What Needs Implementation üîÑ
- **TinyMCP Component**: Port core MCP classes to ESP32-C6
- **C++ Conversion**: Convert `firmware.c` to `firmware.cpp`
- **MCP Transport**: Implement UART/USB CDC JSON-RPC transport
- **ESP32 MCP Tools**: Create DisplayTool, GPIOTool, SystemTool
- **JSON Processing**: Replace jsoncpp with ESP-IDF cJSON
- **Task Integration**: Add MCP server as FreeRTOS task

### Development Status Summary üìä
- **Firmware**: 100% functional with display, GPIO, system monitoring
- **Development Tools**: 100% functional with enhanced monitoring
- **TinyMCP Architecture**: 100% analyzed and planned
- **TinyMCP Implementation**: 0% (ready to begin Phase 1)

## RESOURCES & REFERENCES

### Essential Documentation
- ESP-IDF Programming Guide: https://docs.espressif.com/projects/esp-idf/en/stable/esp32c6/
- ESP32-C6 Technical Reference: https://www.espressif.com/sites/default/files/documentation/esp32-c6_technical_reference_manual_en.pdf
- ESP-IDF Examples: Local at `$IDF_PATH/examples/`

### Key Commands Reference

#### Enhanced Development Script (RECOMMENDED)
```bash
# Primary development workflow
./dev_monitor.sh flash-test          # Build, flash, and quick test
./dev_monitor.sh dual 120            # Dual monitoring (2 minutes)
./dev_monitor.sh build               # Build firmware only
./dev_monitor.sh logs combined       # View correlated logs

# See DEV_MONITOR_README.md for complete command reference
./dev_monitor.sh help
```

#### Manual ESP-IDF Commands (for advanced use)
```bash
# Environment setup (done automatically by dev_monitor.sh)
export IDF_PATH=/home/mike/esp/esp-idf && source $IDF_PATH/export.sh

# Manual project commands (use dev_monitor.sh instead)
cd firmware
idf.py build
idf.py -p /dev/ttyACM0 flash monitor
idf.py menuconfig
```

## TINYMCP SPECIFIC RESOURCES

### TinyMCP Documentation
- **Reference Implementation**: `ESP-C6/REF-CODE/` (C++ SDK)
- **MCP Protocol Specification**: [MCP Specification 2024-11-05](https://modelcontextprotocol.io/specification/2024-11-05/index)
- **MCP Introduction**: [Model Context Protocol Overview](https://modelcontextprotocol.io/introduction)
- **TinyMCP Wiki**: [GitHub Wiki](https://github.com/Qihoo360/TinyMCP/wiki)

### ESP32-C6 + TinyMCP Integration Commands
```bash
# Environment setup for TinyMCP development
export IDF_PATH=/home/mike/esp/esp-idf && source $IDF_PATH/export.sh

# Enable C++ support in menuconfig
idf.py menuconfig
# Navigate to: Component config ‚Üí Compiler options ‚Üí Enable C++ exceptions

# Build with TinyMCP component
idf.py build

# Flash and monitor with MCP server
idf.py -p /dev/ttyACM0 flash monitor

# Test MCP server (from another terminal)
# The ESP32 will act as MCP server on USB CDC
```

### TinyMCP Development Guidelines

#### JSON Library Selection
- **DO NOT** port jsoncpp - too heavy for ESP32
- **USE** ESP-IDF's built-in `cJSON` component
- **CREATE** lightweight JSON wrapper matching TinyMCP API

#### Memory Management
- **USE** ESP32 heap functions: `heap_caps_malloc()`, `heap_caps_free()`
- **AVOID** std::vector, std::string - use ESP32 alternatives
- **IMPLEMENT** object pooling for frequent allocations

#### Threading Model
- **REPLACE** std::thread with `xTaskCreate()`
- **USE** FreeRTOS mutexes instead of std::mutex
- **IMPLEMENT** proper task priorities and stack sizes

#### Transport Layer Priority
1. **UART/USB CDC** - Primary interface for development
2. **WiFi TCP** - For remote access and web integration
3. **BLE** - For mobile app connectivity (optional)

## FINAL NOTE TO FUTURE AGENTS

### Development Workflow (MANDATORY)
**USE THE ENHANCED DEVELOPMENT SCRIPT FOR ALL OPERATIONS!**

```bash
# Start here for any development work
./dev_monitor.sh help              # See all available commands
./dev_monitor.sh flash-test        # Verify everything works
./dev_monitor.sh dual 300          # Development with dual monitoring
```

**Read `DEV_MONITOR_README.md` for complete development guidance.**

### ESP-IDF Development Principles
**ALWAYS USE EXISTING ESP-IDF COMPONENTS AND EXAMPLES FIRST!**

The ESP-IDF framework is mature and comprehensive. There's almost always an existing component or example that does what you need. Spend time understanding and adapting existing code rather than writing from scratch.

### TinyMCP Integration Principles
**FOLLOW THE PHASED IMPLEMENTATION PLAN!**

1. **Start with Phase 1**: Set up component structure and build system
2. **Port incrementally**: Don't attempt to port everything at once
3. **Test frequently**: Use `./dev_monitor.sh dual` to validate each component
4. **Use ESP32 patterns**: Adapt TinyMCP to ESP-IDF conventions, not vice versa
5. **Maintain functionality**: Keep existing display/GPIO features working

### Debug and Development Strategy
1. **Use enhanced development tools** - `./dev_monitor.sh` provides comprehensive monitoring
2. **Use existing firmware as baseline** - it's working and stable
3. **Add MCP functionality incrementally** - don't break existing features
4. **Test transport layer first** - ensure communication works before adding tools
5. **Monitor with dual logging** - use correlated client/server logs for debugging
6. **Validate with simple tools** - start with echo/ping before complex tools

### Essential Documentation
- **`DEV_MONITOR_README.md`**: Complete development and testing guide
- **`README.md`**: Project overview and hardware setup
- **This file (`AGENTS.md`)**: Architecture principles and lessons learned

When in doubt, check the official examples and documentation before implementing anything custom. The TinyMCP integration should enhance, not replace, the existing solid foundation.